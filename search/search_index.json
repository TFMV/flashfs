{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlashFS Documentation","text":"<p>FlashFS is a high-performance file system snapshot and diff tool designed for efficiently tracking and managing changes across file systems over time.</p>"},{"location":"#overview","title":"Overview","text":"<p>FlashFS allows you to:</p> <ul> <li>Create snapshots of your file system's state at a point in time</li> <li>Compare snapshots to identify exactly what has changed</li> <li>Generate and apply diffs between snapshots for efficient incremental backups</li> <li>Manage snapshot lifecycle with flexible expiry policies</li> <li>Query snapshots to find specific files or directories</li> </ul> <p>FlashFS is optimized for performance, with features like parallel processing, efficient binary serialization, content-based deduplication, and intelligent caching.</p>"},{"location":"#key-components","title":"Key Components","text":"<p>FlashFS consists of several modular components, each responsible for a specific aspect of the system:</p> Component Description CLI Command-line interface for interacting with FlashFS Walker Traverses file systems to collect metadata Serializer Converts metadata to efficient binary format Schema Defines data structures using FlatBuffers Storage Manages storage and retrieval of snapshots and diffs Diff Computation Computes and applies differences between snapshots Expiry Policy Manages snapshot lifecycle and cleanup"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>go install github.com/TFMV/flashfs@latest\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Create a snapshot:</p> <pre><code>flashfs snapshot create --source /path/to/directory --output my-snapshot.snap\n</code></pre> <p>Compare two snapshots:</p> <pre><code>flashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff\n</code></pre> <p>Apply a diff to generate a new snapshot:</p> <pre><code>flashfs apply --base snapshot1.snap --diff changes.diff --output snapshot2.snap\n</code></pre> <p>List snapshots:</p> <pre><code>flashfs snapshot list --dir /path/to/snapshots\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":"<p>FlashFS includes advanced features like:</p> <ul> <li>Bloom filters for rapid change detection</li> <li>Content-based deduplication using BLAKE3 hashing</li> <li>Parallel processing for faster snapshot and diff operations</li> <li>Configurable compression using zstd</li> <li>Efficient caching for frequently accessed snapshots</li> <li>Query capabilities for finding specific files in snapshots</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>FlashFS is designed for high performance:</p> <ul> <li>Fast snapshot creation with parallel file system traversal</li> <li>Efficient binary serialization using FlatBuffers</li> <li>Minimal memory usage with streaming processing</li> <li>Quick diff computation using Bloom filters for pre-filtering</li> <li>Optimal compression with zstd for storage efficiency</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Backup systems: Create incremental backups by storing only changes</li> <li>File synchronization: Identify differences between systems efficiently</li> <li>Change monitoring: Track file system changes over time</li> <li>Deployment verification: Ensure consistency across deployed systems</li> <li>Data migration: Track changes during migration processes</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed information on each component, please refer to the dedicated documentation pages linked in the Key Components section above.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>FlashFS provides a comprehensive command-line interface (CLI) for interacting with snapshots, diffs, and expiry policies. The CLI is built using Cobra, a powerful library for creating modern CLI applications.</p>"},{"location":"cli/#overview","title":"Overview","text":"<p>The FlashFS CLI includes commands for:</p> <ul> <li>Creating and managing snapshots</li> <li>Computing and applying diffs between snapshots</li> <li>Querying snapshot contents</li> <li>Managing snapshot expiry policies</li> </ul>"},{"location":"cli/#command-structure","title":"Command Structure","text":"<pre><code>flashfs\n\u251c\u2500\u2500 snapshot - Create a snapshot of a directory\n\u251c\u2500\u2500 diff - Compute differences between snapshots\n\u251c\u2500\u2500 apply - Apply a diff to a snapshot\n\u251c\u2500\u2500 query - Query snapshot contents\n\u2514\u2500\u2500 expiry - Manage snapshot expiry policies\n    \u251c\u2500\u2500 set - Set expiry policy\n    \u251c\u2500\u2500 apply - Apply expiry policy\n    \u2514\u2500\u2500 show - Show current expiry policy\n</code></pre>"},{"location":"cli/#global-flags","title":"Global Flags","text":"<p>These flags apply to all commands:</p> <pre><code>--help, -h     Show help for a command\n--verbose, -v  Enable verbose output\n</code></pre>"},{"location":"cli/#snapshot-command","title":"Snapshot Command","text":"<p>Create a snapshot of a directory.</p> <pre><code>flashfs snapshot [flags]\n</code></pre>"},{"location":"cli/#flags","title":"Flags","text":"<pre><code>--path, -p string     Directory to snapshot (required)\n--output, -o string   Output snapshot file (required)\n--exclude string      Exclude pattern (e.g., \"*.tmp,*.log\")\n--no-hash             Skip file content hashing\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":"<pre><code># Create a snapshot of the current directory\nflashfs snapshot --path . --output backup.snap\n\n# Create a snapshot excluding temporary files\nflashfs snapshot --path /home/user/documents --output docs.snap --exclude \"*.tmp,*.bak\"\n\n# Create a snapshot without computing file hashes (faster but less accurate)\nflashfs snapshot --path /var/www --output web.snap --no-hash\n</code></pre>"},{"location":"cli/#diff-command","title":"Diff Command","text":"<p>Compute differences between snapshots and store them in a structured format.</p> <pre><code>flashfs diff [flags]\n</code></pre>"},{"location":"cli/#flags_1","title":"Flags","text":"<pre><code>--base, -b string     Base snapshot file (required)\n--target, -t string   Target snapshot file (required)\n--output, -o string   Output diff file (required)\n--detailed            Perform detailed comparison including file content hashes\n--parallel int        Number of parallel workers for comparison (default: number of CPU cores)\n--no-hash             Skip hash comparison (faster but less accurate)\n--path-filter string  Only compare files matching the specified path pattern\n</code></pre>"},{"location":"cli/#examples_1","title":"Examples","text":"<pre><code># Compute differences between two snapshots\nflashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff\n\n# Detailed comparison with 8 parallel workers\nflashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff --detailed --parallel 8\n\n# Compare only files in a specific directory\nflashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff --path-filter \"/home/user/documents/*\"\n</code></pre>"},{"location":"cli/#diff-format","title":"Diff Format","text":"<p>The generated diff file contains a structured representation of changes:</p> <ul> <li>Added files: Files that exist in the target snapshot but not in the base snapshot</li> <li>Modified files: Files that exist in both snapshots but have different metadata or content</li> <li>Deleted files: Files that exist in the base snapshot but not in the target snapshot</li> </ul> <p>Each change is stored as a <code>DiffEntry</code> with:</p> <ul> <li>Path of the changed file</li> <li>Type of change (added, modified, deleted)</li> <li>Before and after values for size, modification time, permissions, and content hash (as applicable)</li> </ul> <p>This structured format enables efficient application of changes and provides detailed information about what has changed between snapshots.</p>"},{"location":"cli/#apply-command","title":"Apply Command","text":"<p>Apply a diff to a snapshot to generate a new snapshot.</p> <pre><code>flashfs apply [flags]\n</code></pre>"},{"location":"cli/#flags_2","title":"Flags","text":"<pre><code>--base, -b string    Base snapshot file (required)\n--diff, -d string    Diff file to apply (required)\n--output, -o string  Output snapshot file (required)\n</code></pre>"},{"location":"cli/#examples_2","title":"Examples","text":"<pre><code># Apply a diff to generate a new snapshot\nflashfs apply --base snapshot1.snap --diff changes.diff --output snapshot2.snap\n</code></pre>"},{"location":"cli/#how-apply-works","title":"How Apply Works","text":"<p>The apply command:</p> <ol> <li>Loads the base snapshot into memory</li> <li>Deserializes the diff file into a structured Diff object</li> <li>Processes each DiffEntry based on its type:</li> <li>For added files (type 0): Creates a new entry in the snapshot</li> <li>For modified files (type 1): Updates the existing entry with new metadata</li> <li>For deleted files (type 2): Removes the entry from the snapshot</li> <li>Serializes the modified snapshot and writes it to the output file</li> </ol> <p>This structured approach ensures that changes are applied correctly and efficiently, maintaining the integrity of your file system representation.</p>"},{"location":"cli/#query-command","title":"Query Command","text":"<p>Query snapshot contents.</p> <pre><code>flashfs query [flags]\n</code></pre>"},{"location":"cli/#flags_3","title":"Flags","text":"<pre><code>--snapshot, -s string       Snapshot file to query (required)\n--path string               Path pattern to filter by (e.g., \"/home/user/*\")\n--modified-after string     Show files modified after this date (format: YYYY-MM-DD)\n--modified-before string    Show files modified before this date (format: YYYY-MM-DD)\n--size-gt int               Show files larger than this size (in bytes)\n--size-lt int               Show files smaller than this size (in bytes)\n--is-dir                    Show only directories\n--is-file                   Show only files\n--format string             Output format: text, json, csv (default \"text\")\n</code></pre>"},{"location":"cli/#examples_3","title":"Examples","text":"<pre><code># List all files in a snapshot\nflashfs query --snapshot backup.snap\n\n# Find large files modified recently\nflashfs query --snapshot backup.snap --size-gt 10485760 --modified-after \"2023-01-01\"\n\n# Find all .log files in a specific directory\nflashfs query --snapshot backup.snap --path \"/var/log/*.log\"\n\n# Export results as JSON\nflashfs query --snapshot backup.snap --path \"*.mp4\" --format json &gt; videos.json\n</code></pre>"},{"location":"cli/#expiry-command","title":"Expiry Command","text":"<p>Manage snapshot expiry policies.</p> <pre><code>flashfs expiry [command]\n</code></pre>"},{"location":"cli/#subcommands","title":"Subcommands","text":""},{"location":"cli/#set","title":"Set","text":"<p>Set the expiry policy for snapshots.</p> <pre><code>flashfs expiry set [flags]\n</code></pre>"},{"location":"cli/#flags_4","title":"Flags","text":"<pre><code>--max-snapshots int    Maximum number of snapshots to keep (0 = unlimited)\n--max-age string       Maximum age of snapshots to keep (e.g., 30d, 2w, 6m, 1y)\n--keep-hourly int      Number of hourly snapshots to keep\n--keep-daily int       Number of daily snapshots to keep\n--keep-weekly int      Number of weekly snapshots to keep\n--keep-monthly int     Number of monthly snapshots to keep\n--keep-yearly int      Number of yearly snapshots to keep\n--apply                Apply the policy immediately after setting it\n--dir string           Base directory for snapshots (default: current directory)\n</code></pre>"},{"location":"cli/#examples_4","title":"Examples","text":"<pre><code># Keep only the 10 most recent snapshots\nflashfs expiry set --max-snapshots 10\n\n# Remove snapshots older than 30 days\nflashfs expiry set --max-age 30d\n\n# Set a comprehensive retention policy\nflashfs expiry set --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12 --keep-yearly 5\n\n# Set a policy and apply it immediately\nflashfs expiry set --max-age 30d --apply\n</code></pre>"},{"location":"cli/#apply","title":"Apply","text":"<p>Apply the current expiry policy to snapshots.</p> <pre><code>flashfs expiry apply [flags]\n</code></pre>"},{"location":"cli/#flags_5","title":"Flags","text":"<pre><code>--dir string  Base directory for snapshots (default: current directory)\n</code></pre>"},{"location":"cli/#examples_5","title":"Examples","text":"<pre><code># Apply the current expiry policy\nflashfs expiry apply\n\n# Apply the policy to snapshots in a specific directory\nflashfs expiry apply --dir /path/to/snapshots\n</code></pre>"},{"location":"cli/#show","title":"Show","text":"<p>Show the current expiry policy.</p> <pre><code>flashfs expiry show [flags]\n</code></pre>"},{"location":"cli/#flags_6","title":"Flags","text":"<pre><code>--dir string  Base directory for snapshots (default: current directory)\n</code></pre>"},{"location":"cli/#examples_6","title":"Examples","text":"<pre><code># Show the current expiry policy\nflashfs expiry show\n\n# Show the policy for snapshots in a specific directory\nflashfs expiry show --dir /path/to/snapshots\n</code></pre>"},{"location":"cli/#implementation-details","title":"Implementation Details","text":""},{"location":"cli/#command-registration","title":"Command Registration","text":"<p>Commands are registered in the <code>cmd</code> package:</p> <pre><code>func init() {\n    RootCmd.AddCommand(snapshotCmd)\n    RootCmd.AddCommand(diffCmd)\n    RootCmd.AddCommand(applyCmd)\n    RootCmd.AddCommand(queryCmd)\n    RootCmd.AddCommand(expiryCmd)\n\n    // Register expiry subcommands\n    expiryCmd.AddCommand(setExpiryCmd)\n    expiryCmd.AddCommand(applyExpiryCmd)\n    expiryCmd.AddCommand(showExpiryCmd)\n}\n</code></pre>"},{"location":"cli/#command-execution","title":"Command Execution","text":"<p>Each command is implemented as a Cobra command with a <code>RunE</code> function:</p> <pre><code>var snapshotCmd = &amp;cobra.Command{\n    Use:   \"snapshot\",\n    Short: \"Create a snapshot of a directory\",\n    Long:  `Create a snapshot of a directory, capturing file metadata and optionally content hashes.`,\n    RunE: func(cmd *cobra.Command, args []string) error {\n        // Command implementation\n        // ...\n        return nil\n    },\n}\n</code></pre>"},{"location":"cli/#error-handling","title":"Error Handling","text":"<p>The CLI provides detailed error messages and appropriate exit codes:</p> <pre><code>if err != nil {\n    fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n    os.Exit(1)\n}\n</code></pre>"},{"location":"cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"cli/#scripting","title":"Scripting","text":"<p>FlashFS commands can be used in scripts for automation:</p> <pre><code>#!/bin/bash\n# Create daily snapshots and apply expiry policy\n\n# Create a snapshot with the current date\nDATE=$(date +%Y%m%d)\nflashfs snapshot --path /home/user/documents --output backup-$DATE.snap\n\n# Apply expiry policy to clean up old snapshots\nflashfs expiry apply\n</code></pre>"},{"location":"cli/#piping-output","title":"Piping Output","text":"<p>Query results can be piped to other commands:</p> <pre><code># Find large files and sort by size\nflashfs query --snapshot backup.snap --size-gt 10485760 --format csv | sort -t, -k2 -n\n\n# Find recent changes and send a report by email\nflashfs query --snapshot backup.snap --modified-after \"2023-01-01\" | mail -s \"Recent Changes\" user@example.com\n</code></pre>"},{"location":"cli/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>FlashFS can be integrated with other tools:</p> <pre><code># Use with find to process multiple directories\nfind /home -type d -name \"projects\" | xargs -I{} flashfs snapshot --path {} --output {}.snap\n\n# Use with cron for scheduled snapshots\n# Add to crontab: 0 0 * * * /path/to/snapshot_script.sh\n</code></pre>"},{"location":"diff/","title":"Diff Computation","text":"<p>FlashFS provides powerful diff computation capabilities that enable efficient comparison, storage, and application of changes between snapshots. This feature is essential for incremental backups, file synchronization, and monitoring changes over time.</p>"},{"location":"diff/#benefits","title":"Benefits","text":"<ul> <li>Storage Efficiency: Store only the changes between snapshots instead of full copies</li> <li>Transfer Optimization: Transmit only the differences when synchronizing snapshots</li> <li>Change Tracking: Easily identify what files have been added, modified, or deleted</li> <li>Performance: Utilize parallel processing and pre-filtering for fast comparisons</li> <li>Flexibility: Configure comparison options based on specific needs</li> </ul>"},{"location":"diff/#how-diff-computation-works","title":"How Diff Computation Works","text":"<p>FlashFS implements a multi-stage approach to efficiently compute differences between snapshots:</p>"},{"location":"diff/#1-bloom-filter-pre-check","title":"1. Bloom Filter Pre-check","text":"<p>Before performing detailed comparisons, FlashFS uses Bloom filters to quickly identify files that may have changed:</p> <ol> <li>Creates a Bloom filter from the base snapshot</li> <li>Tests each file in the target snapshot against the filter</li> <li>Files that fail the Bloom filter test are candidates for detailed comparison</li> </ol> <p>This pre-filtering step significantly reduces the number of files that need detailed comparison, especially in large snapshots where most files remain unchanged.</p>"},{"location":"diff/#2-detailed-comparison","title":"2. Detailed Comparison","text":"<p>For files identified by the Bloom filter, FlashFS performs a detailed comparison:</p> <ol> <li>Compares file metadata (path, size, modification time, permissions)</li> <li>Optionally compares file content hashes for detecting changes even when metadata is unchanged</li> <li>Identifies files that have been added, modified, or deleted</li> </ol>"},{"location":"diff/#3-structured-diff-representation","title":"3. Structured Diff Representation","text":"<p>FlashFS uses a structured schema to represent diffs:</p> <ol> <li>Each changed file is represented as a <code>DiffEntry</code> with:</li> <li>Path of the file</li> <li>Type of change (added, modified, deleted)</li> <li> <p>Before and after values for size, modification time, permissions, and content hash</p> </li> <li> <p>All entries are collected in a <code>Diff</code> object that provides:</p> </li> <li>Efficient serialization and deserialization</li> <li>Type-safe access to change information</li> <li>Structured representation of all changes</li> </ol>"},{"location":"diff/#4-parallel-processing","title":"4. Parallel Processing","text":"<p>To accelerate diff computation for large snapshots, FlashFS can distribute the comparison work across multiple CPU cores:</p> <ol> <li>Divides the file list into chunks</li> <li>Processes each chunk in parallel</li> <li>Combines the results into a unified diff</li> </ol>"},{"location":"diff/#5-diff-storage","title":"5. Diff Storage","text":"<p>The computed diff is stored in a compact format:</p> <ol> <li>Records only the changes (added, modified, deleted files)</li> <li>Uses the same efficient FlatBuffers serialization as snapshots</li> <li>Applies Zstd compression to minimize storage requirements</li> </ol>"},{"location":"diff/#command-reference","title":"Command Reference","text":""},{"location":"diff/#computing-a-diff","title":"Computing a Diff","text":"<pre><code>flashfs diff [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--base &lt;file&gt;</code>: Base snapshot file (required)</li> <li><code>--target &lt;file&gt;</code>: Target snapshot file (required)</li> <li><code>--output &lt;file&gt;</code>: Output diff file (required)</li> <li><code>--detailed</code>: Perform detailed comparison including file content hashes</li> <li><code>--parallel &lt;n&gt;</code>: Number of parallel workers for comparison (default: number of CPU cores)</li> <li><code>--no-hash</code>: Skip hash comparison (faster but less accurate)</li> <li><code>--path-filter &lt;pattern&gt;</code>: Only compare files matching the specified path pattern</li> </ul>"},{"location":"diff/#applying-a-diff","title":"Applying a Diff","text":"<pre><code>flashfs apply [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--base &lt;file&gt;</code>: Base snapshot file (required)</li> <li><code>--diff &lt;file&gt;</code>: Diff file to apply (required)</li> <li><code>--output &lt;file&gt;</code>: Output snapshot file (required)</li> </ul>"},{"location":"diff/#viewing-diff-information","title":"Viewing Diff Information","text":"<pre><code>flashfs diff-info [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--diff &lt;file&gt;</code>: Diff file to analyze (required)</li> <li><code>--verbose</code>: Show detailed information about each changed file</li> </ul>"},{"location":"diff/#examples","title":"Examples","text":""},{"location":"diff/#basic-diff-computation","title":"Basic Diff Computation","text":"<p>Compute the differences between two snapshots:</p> <pre><code>flashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff\n</code></pre>"},{"location":"diff/#detailed-comparison-with-parallel-processing","title":"Detailed Comparison with Parallel Processing","text":"<p>Perform a detailed comparison using 8 parallel workers:</p> <pre><code>flashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff --detailed --parallel 8\n</code></pre>"},{"location":"diff/#path-filtered-comparison","title":"Path-Filtered Comparison","text":"<p>Compare only files in a specific directory:</p> <pre><code>flashfs diff --base snapshot1.snap --target snapshot2.snap --output changes.diff --path-filter \"/home/user/documents/*\"\n</code></pre>"},{"location":"diff/#applying-a-diff-to-generate-a-new-snapshot","title":"Applying a Diff to Generate a New Snapshot","text":"<p>Apply a diff to a base snapshot to generate a new snapshot:</p> <pre><code>flashfs apply --base snapshot1.snap --diff changes.diff --output snapshot2.snap\n</code></pre>"},{"location":"diff/#viewing-diff-information_1","title":"Viewing Diff Information","text":"<p>Analyze the contents of a diff file:</p> <pre><code>flashfs diff-info --diff changes.diff --verbose\n</code></pre>"},{"location":"diff/#implementation-details","title":"Implementation Details","text":"<p>The diff computation is implemented in the <code>SnapshotStore</code> struct with the following key methods:</p> <ul> <li><code>ComputeDiff</code>: Computes the differences between two snapshots and returns a structured <code>Diff</code> object</li> <li><code>StoreDiff</code>: Stores the computed diff to a file</li> <li><code>ApplyDiff</code>: Applies a diff to a base snapshot to generate a new snapshot</li> </ul>"},{"location":"diff/#diff-schema","title":"Diff Schema","text":"<p>FlashFS uses a structured schema for representing diffs:</p> <pre><code>table DiffEntry {\n  path: string;\n  type: byte;  // 0 = added, 1 = modified, 2 = deleted\n  oldSize: long;\n  newSize: long;\n  oldMtime: long;\n  newMtime: long;\n  oldPermissions: uint;\n  newPermissions: uint;\n  oldHash: [ubyte];\n  newHash: [ubyte];\n}\n\ntable Diff {\n  entries: [DiffEntry];\n}\n</code></pre> <p>This schema provides a clear, structured representation of changes, with each <code>DiffEntry</code> capturing all relevant information about a change:</p> <ul> <li>For added files (<code>type = 0</code>), only the new metadata is relevant</li> <li>For modified files (<code>type = 1</code>), both old and new metadata are stored</li> <li>For deleted files (<code>type = 2</code>), only the old metadata is relevant</li> </ul>"},{"location":"diff/#computediff-implementation","title":"ComputeDiff Implementation","text":"<p>The <code>ComputeDiff</code> function compares two snapshots and produces a structured diff:</p> <ol> <li>Deserializes both snapshots</li> <li>Creates maps of file entries for efficient lookup</li> <li>Identifies added, modified, and deleted files</li> <li>Creates <code>DiffEntry</code> objects for each change</li> <li>Assembles all entries into a <code>Diff</code> object</li> <li>Serializes the diff using FlatBuffers</li> <li>Compresses the serialized data</li> </ol>"},{"location":"diff/#applydiff-implementation","title":"ApplyDiff Implementation","text":"<p>The <code>ApplyDiff</code> function applies a diff to a base snapshot:</p> <ol> <li>Deserializes the base snapshot</li> <li>Deserializes the diff</li> <li>Creates a map of base entries</li> <li>Processes each diff entry:</li> <li>For added files, creates a new entry</li> <li>For modified files, updates the existing entry</li> <li>For deleted files, removes the entry</li> <li>Builds a new snapshot with the modified entries</li> <li>Serializes and compresses the new snapshot</li> </ol> <p>The diff system uses the same efficient serialization and compression techniques as the snapshot system, ensuring consistent performance and storage efficiency.</p>"},{"location":"diff/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Bloom Filters: The Bloom filter pre-check significantly reduces comparison time for large snapshots</li> <li>Parallel Processing: Utilizing multiple CPU cores can dramatically speed up diff computation</li> <li>Hash Comparison: Enabling hash comparison provides more accurate results but increases computation time</li> <li>Path Filtering: Using path filters can focus the comparison on relevant files, reducing processing time</li> <li>Structured Diffs: The structured diff format allows for efficient processing and application of changes</li> </ul> <p>For optimal performance, adjust the parallelism level based on your system's capabilities and use path filters when only specific directories are of interest.</p>"},{"location":"expiry-policy/","title":"Snapshot Expiry Policy","text":"<p>FlashFS provides a robust snapshot lifecycle management system through configurable expiry policies. This feature allows you to automatically manage the retention and deletion of snapshots based on various criteria.</p>"},{"location":"expiry-policy/#benefits","title":"Benefits","text":"<ul> <li>Automated Cleanup: Automatically remove old or unnecessary snapshots</li> <li>Storage Optimization: Prevent storage space from being consumed by outdated snapshots</li> <li>Flexible Retention: Configure granular retention policies based on time periods</li> <li>Policy Combinations: Combine different policy types for comprehensive lifecycle management</li> </ul>"},{"location":"expiry-policy/#expiry-policy-types","title":"Expiry Policy Types","text":"<p>FlashFS supports several types of expiry policies that can be used individually or in combination:</p>"},{"location":"expiry-policy/#1-maximum-snapshots-limit","title":"1. Maximum Snapshots Limit","text":"<p>Limit the total number of snapshots to keep, removing the oldest ones when the limit is exceeded.</p> <pre><code>flashfs expiry set --max-snapshots 50\n</code></pre>"},{"location":"expiry-policy/#2-maximum-age-limit","title":"2. Maximum Age Limit","text":"<p>Automatically remove snapshots older than a specified duration.</p> <pre><code>flashfs expiry set --max-age 90d  # Keep snapshots for 90 days\n</code></pre> <p>Supported duration units:</p> <ul> <li><code>h</code> or <code>hour(s)</code> - Hours</li> <li><code>d</code> or <code>day(s)</code> - Days</li> <li><code>w</code> or <code>week(s)</code> - Weeks</li> <li><code>m</code> or <code>month(s)</code> - Months (30 days)</li> <li><code>y</code> or <code>year(s)</code> - Years (365 days)</li> </ul>"},{"location":"expiry-policy/#3-time-based-retention-policies","title":"3. Time-Based Retention Policies","text":"<p>Keep a specific number of snapshots at different time intervals:</p> <pre><code># Keep 24 hourly, 7 daily, 4 weekly, 12 monthly, and 5 yearly snapshots\nflashfs expiry set --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12 --keep-yearly 5\n</code></pre> <ul> <li>Hourly: Keep the most recent snapshot from each hour</li> <li>Daily: Keep the most recent snapshot from each day</li> <li>Weekly: Keep the most recent snapshot from each week</li> <li>Monthly: Keep the most recent snapshot from each month</li> <li>Yearly: Keep the most recent snapshot from each year</li> </ul>"},{"location":"expiry-policy/#how-it-works","title":"How It Works","text":"<p>When applying an expiry policy, FlashFS:</p> <ol> <li>Sorts all snapshots by timestamp (newest first)</li> <li>Identifies snapshots to keep based on retention policies</li> <li>Applies maximum snapshots limit (if configured)</li> <li>Applies maximum age limit (if configured)</li> <li>Deletes snapshots that don't meet the retention criteria</li> </ol> <p>The policy is automatically applied when creating new snapshots, or can be manually applied using the <code>expiry apply</code> command.</p>"},{"location":"expiry-policy/#command-reference","title":"Command Reference","text":""},{"location":"expiry-policy/#setting-an-expiry-policy","title":"Setting an Expiry Policy","text":"<pre><code>flashfs expiry set [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--max-snapshots &lt;number&gt;</code>: Maximum number of snapshots to keep (0 = unlimited)</li> <li><code>--max-age &lt;duration&gt;</code>: Maximum age of snapshots to keep (e.g., 30d, 2w, 6m, 1y)</li> <li><code>--keep-hourly &lt;number&gt;</code>: Number of hourly snapshots to keep</li> <li><code>--keep-daily &lt;number&gt;</code>: Number of daily snapshots to keep</li> <li><code>--keep-weekly &lt;number&gt;</code>: Number of weekly snapshots to keep</li> <li><code>--keep-monthly &lt;number&gt;</code>: Number of monthly snapshots to keep</li> <li><code>--keep-yearly &lt;number&gt;</code>: Number of yearly snapshots to keep</li> <li><code>--apply</code>: Apply the policy immediately after setting it</li> <li><code>--dir &lt;path&gt;</code>: Base directory for snapshots (defaults to current directory)</li> </ul>"},{"location":"expiry-policy/#applying-an-expiry-policy","title":"Applying an Expiry Policy","text":"<pre><code>flashfs expiry apply [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--dir &lt;path&gt;</code>: Base directory for snapshots (defaults to current directory)</li> </ul>"},{"location":"expiry-policy/#showing-the-current-expiry-policy","title":"Showing the Current Expiry Policy","text":"<pre><code>flashfs expiry show [options]\n</code></pre> <p>Options:</p> <ul> <li><code>--dir &lt;path&gt;</code>: Base directory for snapshots (defaults to current directory)</li> </ul>"},{"location":"expiry-policy/#examples","title":"Examples","text":""},{"location":"expiry-policy/#basic-retention-policy","title":"Basic Retention Policy","text":"<p>Keep the 10 most recent snapshots:</p> <pre><code>flashfs expiry set --max-snapshots 10\n</code></pre>"},{"location":"expiry-policy/#age-based-cleanup","title":"Age-Based Cleanup","text":"<p>Remove snapshots older than 30 days:</p> <pre><code>flashfs expiry set --max-age 30d\n</code></pre>"},{"location":"expiry-policy/#comprehensive-backup-strategy","title":"Comprehensive Backup Strategy","text":"<p>Implement a comprehensive backup strategy with different retention periods:</p> <pre><code>flashfs expiry set --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12 --keep-yearly 5\n</code></pre> <p>This will keep:</p> <ul> <li>24 hourly snapshots (one per hour for the last day)</li> <li>7 daily snapshots (one per day for the last week)</li> <li>4 weekly snapshots (one per week for the last month)</li> <li>12 monthly snapshots (one per month for the last year)</li> <li>5 yearly snapshots (one per year for the last five years)</li> </ul>"},{"location":"expiry-policy/#combined-policy","title":"Combined Policy","text":"<p>Combine different policy types for comprehensive management:</p> <pre><code>flashfs expiry set --max-snapshots 100 --max-age 365d --keep-hourly 24 --keep-daily 7\n</code></pre> <p>This will:</p> <ol> <li>Apply the hourly and daily retention policies</li> <li>Ensure no more than 100 snapshots are kept in total</li> <li>Remove any snapshots older than 365 days</li> </ol>"},{"location":"expiry-policy/#immediate-application","title":"Immediate Application","text":"<p>Set a policy and apply it immediately:</p> <pre><code>flashfs expiry set --max-age 30d --apply\n</code></pre>"},{"location":"expiry-policy/#implementation-details","title":"Implementation Details","text":"<p>The expiry policy is implemented in the <code>SnapshotStore</code> struct and is persisted between sessions. When a new snapshot is created, the policy is automatically applied to clean up old snapshots according to the configured rules.</p> <p>The policy implementation prioritizes retention policies (hourly, daily, etc.) before applying maximum snapshots and maximum age limits. This ensures that important historical snapshots are preserved even when limits are applied.</p>"},{"location":"schema/","title":"Schema","text":"<p>The Schema component in FlashFS defines the data structures used for serialization and deserialization of snapshots and diffs. It uses FlatBuffers to create an efficient, cross-platform binary representation of file system metadata.</p>"},{"location":"schema/#overview","title":"Overview","text":"<p>The Schema component:</p> <ul> <li>Defines the structure of snapshots and diffs</li> <li>Enables efficient binary serialization</li> <li>Provides zero-copy access to serialized data</li> <li>Ensures cross-platform compatibility</li> <li>Allows for schema evolution over time</li> </ul>"},{"location":"schema/#flatbuffers-schema-definition","title":"FlatBuffers Schema Definition","text":"<p>FlashFS uses FlatBuffers as its serialization framework. The schema is defined in the FlatBuffers Interface Definition Language (IDL):</p> <pre><code>namespace flashfs;\n\ntable FileEntry {\n  path: string;\n  size: long;\n  mtime: long;\n  isDir: bool;\n  permissions: uint;\n  hash: [ubyte];\n}\n\ntable Snapshot {\n  entries: [FileEntry];\n}\n\ntable DiffEntry {\n  path: string;\n  type: byte;  // 0 = added, 1 = modified, 2 = deleted\n  oldSize: long;\n  newSize: long;\n  oldMtime: long;\n  newMtime: long;\n  oldPermissions: uint;\n  newPermissions: uint;\n  oldHash: [ubyte];\n  newHash: [ubyte];\n}\n\ntable Diff {\n  entries: [DiffEntry];\n}\n\nroot_type Snapshot;\n</code></pre>"},{"location":"schema/#schema-components","title":"Schema Components","text":""},{"location":"schema/#fileentry","title":"FileEntry","text":"<p>The <code>FileEntry</code> table represents a single file or directory in a snapshot:</p> <ul> <li>path: The relative path within the snapshot</li> <li>size: File size in bytes (0 for directories)</li> <li>mtime: Modification time as Unix timestamp</li> <li>isDir: Whether the entry is a directory</li> <li>permissions: File permissions as a uint32</li> <li>hash: BLAKE3 hash of the file contents (empty for directories)</li> </ul>"},{"location":"schema/#snapshot","title":"Snapshot","text":"<p>The <code>Snapshot</code> table contains a list of file entries that represent the state of a file system at a specific point in time.</p>"},{"location":"schema/#diffentry","title":"DiffEntry","text":"<p>The <code>DiffEntry</code> table represents a change between two snapshots:</p> <ul> <li>path: The path of the changed file or directory</li> <li>type: The type of change (added, modified, deleted)</li> <li>oldSize/newSize: File size before and after the change</li> <li>oldMtime/newMtime: Modification time before and after the change</li> <li>oldPermissions/newPermissions: Permissions before and after the change</li> <li>oldHash/newHash: Content hash before and after the change</li> </ul>"},{"location":"schema/#diff","title":"Diff","text":"<p>The <code>Diff</code> table contains a list of diff entries that represent the changes between two snapshots.</p>"},{"location":"schema/#generated-code","title":"Generated Code","text":"<p>The FlatBuffers compiler generates Go code from the schema definition:</p> <pre><code>// Generated code provides type-safe accessors for all fields\nfunc (e *FileEntry) Path() string\nfunc (e *FileEntry) Size() int64\nfunc (e *FileEntry) Mtime() int64\nfunc (e *FileEntry) IsDir() bool\nfunc (e *FileEntry) Permissions() uint32\nfunc (e *FileEntry) Hash(j int) byte\nfunc (e *FileEntry) HashLength() int\n</code></pre>"},{"location":"schema/#usage-examples","title":"Usage Examples","text":""},{"location":"schema/#accessing-snapshot-data","title":"Accessing Snapshot Data","text":"<pre><code>// Deserialize a snapshot\nsnapshot := flashfs.GetRootAsSnapshot(serializedData, 0)\n\n// Get the number of entries\nentriesLength := snapshot.EntriesLength()\n\n// Access individual entries\nfor i := 0; i &lt; entriesLength; i++ {\n    var entry flashfs.FileEntry\n    if snapshot.Entries(&amp;entry, i) {\n        fmt.Printf(\"Path: %s, Size: %d bytes\\n\", entry.Path(), entry.Size())\n\n        // Access hash bytes if available\n        if entry.HashLength() &gt; 0 {\n            hash := make([]byte, entry.HashLength())\n            for j := 0; j &lt; entry.HashLength(); j++ {\n                hash[j] = entry.Hash(j)\n            }\n            fmt.Printf(\"Hash: %x\\n\", hash)\n        }\n    }\n}\n</code></pre>"},{"location":"schema/#creating-serialized-data","title":"Creating Serialized Data","text":"<pre><code>// Create a FlatBuffers builder\nbuilder := flatbuffers.NewBuilder(0)\n\n// Create file entries\nfileEntryOffsets := make([]flatbuffers.UOffsetT, len(entries))\nfor i, entry := range entries {\n    // Create string and byte vector offsets\n    pathOffset := builder.CreateString(entry.Path)\n    hashOffset := builder.CreateByteVector(entry.Hash)\n\n    // Start building a FileEntry\n    flashfs.FileEntryStart(builder)\n    flashfs.FileEntryAddPath(builder, pathOffset)\n    flashfs.FileEntryAddSize(builder, entry.Size)\n    flashfs.FileEntryAddMtime(builder, entry.ModTime)\n    flashfs.FileEntryAddIsDir(builder, entry.IsDir)\n    flashfs.FileEntryAddPermissions(builder, entry.Permissions)\n    flashfs.FileEntryAddHash(builder, hashOffset)\n\n    // Finish the FileEntry\n    fileEntryOffsets[i] = flashfs.FileEntryEnd(builder)\n}\n\n// Create a vector of file entries\nflashfs.SnapshotStartEntriesVector(builder, len(fileEntryOffsets))\nfor i := len(fileEntryOffsets) - 1; i &gt;= 0; i-- {\n    builder.PrependUOffsetT(fileEntryOffsets[i])\n}\nentriesVector := builder.EndVector(len(fileEntryOffsets))\n\n// Create the snapshot\nflashfs.SnapshotStart(builder)\nflashfs.SnapshotAddEntries(builder, entriesVector)\nsnapshot := flashfs.SnapshotEnd(builder)\n\n// Finish the builder\nbuilder.Finish(snapshot)\n\n// Get the serialized data\nserializedData := builder.FinishedBytes()\n</code></pre>"},{"location":"schema/#schema-evolution","title":"Schema Evolution","text":"<p>The FlatBuffers schema allows for backward-compatible evolution:</p> <ul> <li>Adding Fields: New fields can be added without breaking compatibility with older data</li> <li>Deprecating Fields: Fields can be deprecated without breaking compatibility</li> <li>Versioning: Schema versioning can be implemented through optional fields</li> </ul>"},{"location":"schema/#performance-considerations","title":"Performance Considerations","text":"<p>The Schema component is designed for high performance:</p> <ul> <li>Zero-Copy Deserialization: Accessing data doesn't require unpacking or parsing</li> <li>Memory Efficiency: Binary representation is compact and memory-efficient</li> <li>Cross-Platform: Same binary format works across different platforms</li> <li>Fast Access: Direct access to fields without traversing the entire structure</li> </ul>"},{"location":"schema/#integration-with-other-components","title":"Integration with Other Components","text":"<p>The Schema component integrates with:</p> <ul> <li>Serializer: Provides the structure for serialization</li> <li>Storage: Defines the format for stored snapshots and diffs</li> <li>Diff: Enables efficient representation of changes</li> </ul>"},{"location":"schema/#advanced-topics","title":"Advanced Topics","text":""},{"location":"schema/#custom-schemas","title":"Custom Schemas","text":"<p>For specialized use cases, the schema can be extended:</p> <pre><code>// Extended schema with additional metadata\ntable SnapshotWithMetadata {\n  entries: [FileEntry];\n  creationTime: long;\n  description: string;\n  tags: [string];\n}\n</code></pre>"},{"location":"schema/#schema-versioning","title":"Schema Versioning","text":"<p>To maintain compatibility across versions:</p> <pre><code>// Versioned schema\ntable SnapshotV2 {\n  entries: [FileEntry];\n  version: uint = 2;  // Default value for backward compatibility\n  compressionType: byte = 0;  // New field in version 2\n}\n</code></pre>"},{"location":"schema/#nested-structures","title":"Nested Structures","text":"<p>For more complex data representation:</p> <pre><code>// Nested structures\ntable Directory {\n  path: string;\n  files: [FileEntry];\n  subdirectories: [Directory];\n}\n\ntable HierarchicalSnapshot {\n  rootDirectory: Directory;\n}\n</code></pre>"},{"location":"serializer/","title":"Serializer","text":"<p>The Serializer component in FlashFS is responsible for efficiently converting file system metadata into a compact binary format for storage and transmission. It plays a crucial role in ensuring that snapshots are both space-efficient and quick to process.</p>"},{"location":"serializer/#overview","title":"Overview","text":"<p>The Serializer uses FlatBuffers as its serialization framework, which provides several advantages:</p> <ul> <li>Zero-copy deserialization: Data can be accessed without unpacking/parsing</li> <li>Cross-platform compatibility: Consistent representation across different systems</li> <li>Compact binary format: Minimizes storage requirements</li> <li>Schema evolution: Allows for backward compatibility as the schema evolves</li> </ul>"},{"location":"serializer/#schema-definition","title":"Schema Definition","text":"<p>The serialization schema is defined in FlatBuffers IDL (Interface Definition Language) and includes the following main components:</p> <pre><code>namespace flashfs;\n\ntable FileEntry {\n  path: string;\n  size: long;\n  mtime: long;\n  isDir: bool;\n  permissions: uint;\n  hash: [ubyte];\n}\n\ntable Snapshot {\n  entries: [FileEntry];\n}\n\nroot_type Snapshot;\n</code></pre> <p>This schema defines:</p> <ul> <li>A <code>FileEntry</code> table representing metadata for a single file or directory</li> <li>A <code>Snapshot</code> table containing a list of file entries</li> <li>The root type as <code>Snapshot</code></li> </ul>"},{"location":"serializer/#core-functions","title":"Core Functions","text":""},{"location":"serializer/#serializesnapshot","title":"SerializeSnapshot","text":"<p>The <code>SerializeSnapshot</code> function converts a list of file system entries into a binary representation:</p> <pre><code>func SerializeSnapshot(entries []walker.SnapshotEntry) ([]byte, error)\n</code></pre> <p>This function:</p> <ol> <li>Creates a new FlatBuffers builder</li> <li>Converts each entry into a FlatBuffers <code>FileEntry</code></li> <li>Builds a vector of all file entries</li> <li>Creates a <code>Snapshot</code> containing the entries vector</li> <li>Returns the serialized binary data</li> </ol>"},{"location":"serializer/#deserializesnapshot","title":"DeserializeSnapshot","text":"<p>The <code>DeserializeSnapshot</code> function converts binary data back into a usable format:</p> <pre><code>func DeserializeSnapshot(data []byte) (*flashfs.Snapshot, error)\n</code></pre> <p>This function:</p> <ol> <li>Verifies the binary data</li> <li>Creates a FlatBuffers accessor for the data</li> <li>Returns a reference to the snapshot without copying the data</li> </ol>"},{"location":"serializer/#performance-considerations","title":"Performance Considerations","text":"<p>The Serializer is designed for high performance:</p> <ul> <li>Memory Efficiency: Minimizes memory allocations during serialization</li> <li>Processing Speed: Optimized for fast serialization and deserialization</li> <li>Size Optimization: Creates compact representations of file metadata</li> </ul>"},{"location":"serializer/#integration-with-other-components","title":"Integration with Other Components","text":"<p>The Serializer integrates with:</p> <ul> <li>Walker: Receives file metadata from the Walker component</li> <li>Storage: Provides serialized data to the Storage component for compression and persistence</li> <li>Diff: Enables efficient comparison by providing a consistent representation format</li> </ul>"},{"location":"serializer/#example-usage","title":"Example Usage","text":"<pre><code>// Get file metadata from the Walker\nentries, err := walker.Walk(\"/path/to/directory\")\nif err != nil {\n    return err\n}\n\n// Serialize the entries\nserializedData, err := serializer.SerializeSnapshot(entries)\nif err != nil {\n    return err\n}\n\n// The serialized data can now be compressed and stored\n</code></pre>"},{"location":"serializer/#implementation-details","title":"Implementation Details","text":"<p>The Serializer implementation handles several edge cases:</p> <ul> <li>Large Files: Properly represents files of any size using 64-bit integers</li> <li>Unicode Paths: Correctly handles international characters in file paths</li> <li>Empty Directories: Preserves empty directories in the snapshot</li> <li>Missing Hashes: Gracefully handles entries without content hashes</li> <li>Schema Versioning: Maintains compatibility across different versions</li> </ul>"},{"location":"serializer/#advanced-usage","title":"Advanced Usage","text":""},{"location":"serializer/#custom-serialization","title":"Custom Serialization","text":"<p>For specialized use cases, the Serializer can be extended:</p> <pre><code>// Create a custom serializer with specific options\noptions := serializer.Options{\n    IncludeHashes: true,\n    CompactPaths: false,\n}\nserializedData, err := serializer.SerializeSnapshotWithOptions(entries, options)\n</code></pre>"},{"location":"serializer/#partial-deserialization","title":"Partial Deserialization","text":"<p>For efficiency when only specific data is needed:</p> <pre><code>// Access only the paths without deserializing everything\npaths, err := serializer.ExtractPathsFromSnapshot(serializedData)\n</code></pre>"},{"location":"storage/","title":"Storage","text":"<p>The Storage component is the core of FlashFS, responsible for managing snapshots, diffs, and providing efficient access to stored data. It handles compression, caching, and lifecycle management of snapshots.</p>"},{"location":"storage/#overview","title":"Overview","text":"<p>The Storage component provides a robust API for:</p> <ul> <li>Writing and reading snapshots</li> <li>Computing and applying diffs between snapshots</li> <li>Querying snapshot contents</li> <li>Managing snapshot lifecycle through expiry policies</li> <li>Optimizing performance through caching and Bloom filters</li> </ul>"},{"location":"storage/#snapshotstore","title":"SnapshotStore","text":"<p>The primary interface to the Storage component is the <code>SnapshotStore</code> struct:</p> <pre><code>type SnapshotStore struct {\n    baseDir       string\n    encoder       *zstd.Encoder\n    decoder       *zstd.Decoder\n    cacheMutex    sync.RWMutex\n    snapshotCache map[string][]byte\n    cacheSize     int\n    cacheKeys     []string\n    expiryPolicy  ExpiryPolicy\n}\n</code></pre>"},{"location":"storage/#initialization","title":"Initialization","text":"<p>Create a new <code>SnapshotStore</code> with:</p> <pre><code>store, err := storage.NewSnapshotStore(\"/path/to/snapshots\")\nif err != nil {\n    return err\n}\ndefer store.Close()\n</code></pre> <p>This initializes a store with:</p> <ul> <li>Default compression level (Zstd level 3)</li> <li>Default cache size (10 snapshots)</li> <li>Default expiry policy</li> </ul>"},{"location":"storage/#core-functions","title":"Core Functions","text":""},{"location":"storage/#snapshot-management","title":"Snapshot Management","text":"<pre><code>// Create a new snapshot\nerr := store.CreateSnapshot(\"backup-20230101.snap\", snapshotData)\n\n// Read a snapshot\ndata, err := store.ReadSnapshot(\"backup-20230101.snap\")\n\n// List all snapshots\nsnapshots, err := store.ListSnapshots()\n\n// Delete a snapshot\nerr := store.DeleteSnapshot(\"backup-20230101.snap\")\n</code></pre>"},{"location":"storage/#diff-operations","title":"Diff Operations","text":"<pre><code>// Compute a diff between two snapshots\n// Returns a serialized Diff object containing DiffEntry items\ndiffData, err := store.ComputeDiff(\"backup-20230101.snap\", \"backup-20230102.snap\")\n\n// Store a diff to a file\nerr := store.StoreDiff(\"backup-20230101.snap\", \"backup-20230102.snap\")\n\n// Apply a diff to generate a new snapshot\n// Processes each DiffEntry based on its type (added, modified, deleted)\nnewSnapshotData, err := store.ApplyDiff(\"backup-20230101.snap\", \"diff-20230101-20230102.diff\")\n</code></pre> <p>The diff operations work with structured Diff and DiffEntry types:</p> <pre><code>// DiffEntry represents a single changed file\n// type field indicates: 0 = added, 1 = modified, 2 = deleted\ntype DiffEntry struct {\n    path           string\n    type           byte\n    oldSize        int64\n    newSize        int64\n    oldMtime       int64\n    newMtime       int64\n    oldPermissions uint32\n    newPermissions uint32\n    oldHash        []byte\n    newHash        []byte\n}\n\n// Diff contains all changes between two snapshots\ntype Diff struct {\n    entries []DiffEntry\n}\n</code></pre> <p>The <code>ComputeDiff</code> function compares two snapshots and creates a structured diff with:</p> <ul> <li>Added files (type = 0)</li> <li>Modified files (type = 1)</li> <li>Deleted files (type = 2)</li> </ul> <p>The <code>ApplyDiff</code> function processes each DiffEntry based on its type to:</p> <ul> <li>Add new files to the base snapshot</li> <li>Update modified files in the base snapshot</li> <li>Remove deleted files from the base snapshot</li> </ul>"},{"location":"storage/#querying","title":"Querying","text":"<pre><code>// Query snapshot contents with a filter function\nentries, err := store.QuerySnapshot(\"backup-20230101.snap\", func(entry *flashfs.FileEntry) bool {\n    // Return true for entries to include\n    return strings.HasPrefix(entry.Path(), \"/home/user/documents/\")\n})\n</code></pre>"},{"location":"storage/#expiry-policy-management","title":"Expiry Policy Management","text":"<pre><code>// Set an expiry policy\nstore.SetExpiryPolicy(storage.ExpiryPolicy{\n    MaxSnapshots: 50,\n    MaxAge:       30 * 24 * time.Hour,\n    KeepHourly:   24,\n    KeepDaily:    7,\n})\n\n// Get the current expiry policy\npolicy := store.GetExpiryPolicy()\n\n// Apply the expiry policy to clean up old snapshots\ndeleted, err := store.ApplyExpiryPolicy()\n</code></pre>"},{"location":"storage/#caching","title":"Caching","text":"<p>The Storage component implements an LRU (Least Recently Used) cache for snapshots:</p> <pre><code>// Set the cache size\nstore.SetCacheSize(20)\n\n// The cache is automatically managed when reading snapshots\ndata, err := store.ReadSnapshot(\"backup-20230101.snap\") // Automatically cached\n\n// Subsequent reads of the same snapshot will use the cached version\ndata, err = store.ReadSnapshot(\"backup-20230101.snap\") // Retrieved from cache\n</code></pre>"},{"location":"storage/#bloom-filters","title":"Bloom Filters","text":"<p>Bloom filters are used to quickly identify changed files without full snapshot comparison:</p> <pre><code>// Create a Bloom filter from a snapshot\nfilter, err := store.CreateBloomFilterFromSnapshot(\"backup-20230101.snap\")\n\n// Use the filter to check if a file might have changed\nmightContain := filter.Contains([]byte(\"/path/to/file\"))\n</code></pre>"},{"location":"storage/#file-format","title":"File Format","text":""},{"location":"storage/#snapshots","title":"Snapshots","text":"<p>Snapshots are stored with the <code>.snap</code> extension and contain:</p> <ol> <li>Serialized file metadata in FlatBuffers format</li> <li>Compressed using Zstd</li> </ol>"},{"location":"storage/#diffs","title":"Diffs","text":"<p>Diffs are stored with the <code>.diff</code> extension and contain:</p> <ol> <li>Serialized Diff object with DiffEntry items for added, modified, and deleted files</li> <li>Each DiffEntry contains a type field and relevant metadata for the change</li> <li>Compressed using Zstd</li> </ol>"},{"location":"storage/#performance-considerations","title":"Performance Considerations","text":"<p>The Storage component is optimized for:</p> <ul> <li>Read Performance: Uses caching to minimize disk I/O for frequently accessed snapshots</li> <li>Write Performance: Uses efficient compression to balance speed and size</li> <li>Memory Usage: Controls memory consumption through configurable cache size</li> <li>Comparison Speed: Uses Bloom filters to accelerate diff operations</li> <li>Diff Processing: Structured diff format enables efficient application of changes</li> </ul>"},{"location":"storage/#implementation-details","title":"Implementation Details","text":""},{"location":"storage/#compression","title":"Compression","text":"<p>FlashFS uses Zstd compression with configurable levels:</p> <ul> <li>Default level: 3 (good balance of speed and compression ratio)</li> <li>Faster compression: Use lower levels (1-2)</li> <li>Better compression ratio: Use higher levels (4-9)</li> </ul>"},{"location":"storage/#thread-safety","title":"Thread Safety","text":"<p>The Storage component is thread-safe:</p> <ul> <li>Uses read/write mutexes for cache access</li> <li>Safe for concurrent reads</li> <li>Serializes writes to prevent corruption</li> </ul>"},{"location":"storage/#error-handling","title":"Error Handling","text":"<p>The Storage component provides detailed error information:</p> <ul> <li>File not found errors</li> <li>Permission errors</li> <li>Corruption detection</li> <li>Version incompatibility</li> </ul>"},{"location":"storage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"storage/#custom-compression","title":"Custom Compression","text":"<pre><code>// Create a store with custom compression level\noptions := storage.Options{\n    CompressionLevel: 9, // Maximum compression\n}\nstore, err := storage.NewSnapshotStoreWithOptions(\"/path/to/snapshots\", options)\n</code></pre>"},{"location":"storage/#snapshot-metadata","title":"Snapshot Metadata","text":"<pre><code>// Get metadata about snapshots without loading full contents\nmetadata, err := store.GetSnapshotMetadata(\"backup-20230101.snap\")\nfmt.Printf(\"Size: %d bytes, Created: %s\\n\", metadata.Size, metadata.Timestamp)\n</code></pre>"},{"location":"walker/","title":"Walker","text":"<p>The Walker component in FlashFS is responsible for traversing file systems and collecting metadata about files and directories. It provides the foundation for creating snapshots by efficiently gathering information about the file system structure.</p>"},{"location":"walker/#overview","title":"Overview","text":"<p>The Walker component:</p> <ul> <li>Traverses directories recursively</li> <li>Collects metadata about files and directories</li> <li>Computes content hashes for files</li> <li>Handles errors and edge cases during traversal</li> <li>Supports context-based cancellation</li> </ul>"},{"location":"walker/#core-data-structure","title":"Core Data Structure","text":"<p>The primary data structure used by the Walker is the <code>SnapshotEntry</code>:</p> <pre><code>type SnapshotEntry struct {\n    Path        string\n    Size        int64\n    ModTime     int64\n    IsDir       bool\n    Permissions uint32\n    Hash        []byte\n}\n</code></pre> <p>This structure captures essential information about each file or directory:</p> <ul> <li>Path: The relative path within the snapshot</li> <li>Size: File size in bytes (0 for directories)</li> <li>ModTime: Modification time as Unix timestamp</li> <li>IsDir: Whether the entry is a directory</li> <li>Permissions: File permissions as a uint32</li> <li>Hash: BLAKE3 hash of the file contents (nil for directories)</li> </ul>"},{"location":"walker/#core-functions","title":"Core Functions","text":""},{"location":"walker/#walk","title":"Walk","text":"<p>The primary function for traversing a file system:</p> <pre><code>func Walk(root string) ([]SnapshotEntry, error)\n</code></pre> <p>This function:</p> <ol> <li>Starts at the specified root directory</li> <li>Recursively traverses all subdirectories</li> <li>Collects metadata for each file and directory</li> <li>Returns a slice of <code>SnapshotEntry</code> structures</li> </ol>"},{"location":"walker/#walkwithcontext","title":"WalkWithContext","text":"<p>A context-aware version of the Walk function:</p> <pre><code>func WalkWithContext(ctx context.Context, root string) ([]SnapshotEntry, error)\n</code></pre> <p>This function behaves like <code>Walk</code> but accepts a context that can be used to cancel the operation.</p>"},{"location":"walker/#computehash","title":"ComputeHash","text":"<p>Calculates the BLAKE3 hash of a file:</p> <pre><code>func computeHash(path string) []byte\n</code></pre> <p>This function:</p> <ol> <li>Opens the specified file</li> <li>Streams its contents through the BLAKE3 hash function</li> <li>Returns the resulting hash as a byte slice</li> </ol>"},{"location":"walker/#performance-optimizations","title":"Performance Optimizations","text":"<p>The Walker component includes several optimizations:</p> <ul> <li>Efficient Directory Traversal: Uses the high-performance <code>godirwalk</code> library instead of the standard library's <code>filepath.Walk</code></li> <li>Fast Hashing: Employs BLAKE3, a cryptographic hash function optimized for speed</li> <li>Streaming Processing: Computes hashes by streaming file contents rather than loading entire files into memory</li> <li>Error Handling: Continues traversal even when individual files have errors</li> </ul>"},{"location":"walker/#usage-examples","title":"Usage Examples","text":""},{"location":"walker/#basic-usage","title":"Basic Usage","text":"<pre><code>// Walk a directory and collect file metadata\nentries, err := walker.Walk(\"/path/to/directory\")\nif err != nil {\n    log.Fatalf(\"Failed to walk directory: %v\", err)\n}\n\n// Process the entries\nfor _, entry := range entries {\n    fmt.Printf(\"Path: %s, Size: %d bytes, IsDir: %v\\n\", \n               entry.Path, entry.Size, entry.IsDir)\n}\n</code></pre>"},{"location":"walker/#with-context-for-cancellation","title":"With Context for Cancellation","text":"<pre><code>// Create a context with cancellation\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\n// Walk with context\nentries, err := walker.WalkWithContext(ctx, \"/path/to/directory\")\nif err != nil {\n    if errors.Is(err, context.DeadlineExceeded) {\n        log.Fatal(\"Walk operation timed out\")\n    }\n    log.Fatalf(\"Failed to walk directory: %v\", err)\n}\n</code></pre>"},{"location":"walker/#error-handling","title":"Error Handling","text":"<p>The Walker component handles various error conditions:</p> <ul> <li>Permission Denied: Skips files/directories that cannot be accessed</li> <li>Non-existent Files: Returns appropriate errors for invalid paths</li> <li>I/O Errors: Continues traversal even when individual files have errors</li> <li>Context Cancellation: Stops traversal when the context is cancelled</li> </ul>"},{"location":"walker/#implementation-details","title":"Implementation Details","text":""},{"location":"walker/#directory-traversal","title":"Directory Traversal","text":"<p>The Walker uses <code>godirwalk</code> for efficient directory traversal:</p> <pre><code>err := godirwalk.Walk(root, &amp;godirwalk.Options{\n    Callback: func(path string, de *godirwalk.Dirent) error {\n        // Process each file/directory\n        // ...\n        return nil\n    },\n    Unsorted: true, // For better performance\n})\n</code></pre>"},{"location":"walker/#hash-calculation","title":"Hash Calculation","text":"<p>File content hashes are calculated using BLAKE3:</p> <pre><code>func computeHash(path string) []byte {\n    f, err := os.Open(path)\n    if err != nil {\n        return nil\n    }\n    defer f.Close()\n\n    hasher := blake3.New()\n    if _, err := io.Copy(hasher, f); err != nil {\n        return nil\n    }\n\n    return hasher.Sum(nil)\n}\n</code></pre>"},{"location":"walker/#advanced-usage","title":"Advanced Usage","text":""},{"location":"walker/#custom-traversal-options","title":"Custom Traversal Options","text":"<p>For specialized use cases, the Walker can be extended with custom options:</p> <pre><code>options := walker.Options{\n    SkipHidden: true,\n    MaxDepth: 10,\n    FollowSymlinks: false,\n    IncludePattern: \"*.txt\",\n    ExcludePattern: \".git/*\",\n}\nentries, err := walker.WalkWithOptions(\"/path/to/directory\", options)\n</code></pre>"},{"location":"walker/#parallel-hashing","title":"Parallel Hashing","text":"<p>For improved performance on multi-core systems:</p> <pre><code>options := walker.Options{\n    ParallelHashing: true,\n    HashWorkers: 4,\n}\nentries, err := walker.WalkWithOptions(\"/path/to/directory\", options)\n</code></pre>"},{"location":"walker/#integration-with-other-components","title":"Integration with Other Components","text":"<p>The Walker integrates with:</p> <ul> <li>Serializer: Provides file metadata to be serialized</li> <li>Storage: Indirectly supplies the data for snapshots</li> <li>Diff: Enables comparison by providing consistent metadata</li> </ul>"}]}